<html>
	<head>
		<title>Cubed Demo Three.js</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/r92/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/r92/stats.min.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 
          45,                                       // field of view (in degrees)
          window.innerWidth/window.innerHeight,     // aspect ratio
          0.1,                                      // near clipping plane
          1000                                      // far clipping plane
          );

      var controls = new THREE.OrbitControls( camera );    // create orbit controls
          
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );    // set render resolution
			document.body.appendChild( renderer.domElement );
      
      // stats.js performance monitor
      var stats = new Stats();
      stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
      document.body.appendChild( stats.dom );

			var geometry = new THREE.BoxGeometry( 1, 1, 1 );
      var texture = new THREE.TextureLoader().load( 'image-400x300.jpg' );
      texture.minFilter = THREE.NearestFilter;    // crisper image quality like original image, less blur, more readable
      texture.magFilter = THREE.LinearFilter;    // default, weighted average of mipmaps
			var material = new THREE.MeshLambertMaterial( { map: texture } );
			var cube = new THREE.Mesh( geometry, material );
			scene.add( cube );    // added to center of scene by default
    
      // backup the camera to view cube
      camera.position.set( 0, 0, 6 );   // x,y,z
      
      //controls.update() must be called after any manual changes to the camera's transform
      controls.update();
      
      
      
      // THE GRID
      
      // grid dimensions
      var size = 800;                                               // size of the grids
      var divisions = 10;                                           // number of divisions in the grids
      
      var gridBack = new THREE.GridHelper( size, divisions );       // create a plane grid using GridHelper
      gridBack.position.set(0,0,-(size / 2));                       // centerpoint(x,y,z); at half grid size for a square
      gridBack.rotation.x = Math.PI/2;                              // set grid rotation; rotate 180
      scene.add( gridBack );                                        // add to scene
      
      var gridFront = new THREE.GridHelper( size, divisions );     
      gridFront.position.set(0,0,(size / 2));                            
      gridFront.rotation.x = Math.PI/2;                            
      scene.add( gridFront );

      var gridTop = new THREE.GridHelper( size, divisions );     
      gridTop.position.set(0,(size / 2),0);                                                     
      scene.add( gridTop );
      
      var gridBottom = new THREE.GridHelper( size, divisions );     
      gridBottom.position.set(0,-(size / 2),0);                                                     
      scene.add( gridBottom );
      
      var gridLeft = new THREE.GridHelper( size, divisions );     
      gridLeft.position.set(-(size / 2),0,0);
      gridLeft.rotation.z = Math.PI/2;
      scene.add( gridLeft );
      
      var gridRight = new THREE.GridHelper( size, divisions );     
      gridRight.position.set((size / 2),0,0);
      gridRight.rotation.z = Math.PI/2;
      scene.add( gridRight );

      
      
      
      // LIGHTING
      
      // add soft lighting to entire scene, no light source
      var light = new THREE.AmbientLight( 0x4d4d4d );    // lightness value of 0.30
      scene.add( light );
      
      // (colored) directional light at (0-1) intensity
      var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );    // white, 100%
      directionalLight.position.set(0,1,0.75);    // change light source position property (xyz clip coord)
      scene.add( directionalLight );


			function animate() {

        stats.begin();
        
				cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;

				renderer.render(scene, camera);
        
        stats.end();
        
        requestAnimationFrame( animate );
			};

			requestAnimationFrame( animate );
		</script>
	</body>
</html>