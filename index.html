<html>
	<head>
		<title>Cubed Demo Three.js</title>
    <meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/r92/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/stats.min.js"></script>
		<script>
    
      // global variables
      let camera, scene, renderer;
      let cube;
      let stats;
    
      init();       // initialize; stage everything for first draw
      animate();    // animate and render the scene
      
      
    
      // Initialize
    
      function init() {
        scene = new THREE.Scene();    // initialize a new scene
        camera = new THREE.PerspectiveCamera(       // initialize a camera to view the scene
          45,                                       // field of view (in degrees)
          window.innerWidth/window.innerHeight,     // aspect ratio
          0.1,                                      // near clipping plane
          1000                                      // far clipping plane
          );

        const controls = new THREE.OrbitControls( camera );    // initialize orbit controls (OrbitControls.js)
            
        renderer = new THREE.WebGLRenderer( { antialias: true } );    // initialize threejs renderer
        renderer.setPixelRatio( window.devicePixelRatio );            // set renderer to match device pixel resolution
        renderer.setSize( window.innerWidth, window.innerHeight );    // set render resolution to full window size
        document.body.appendChild( renderer.domElement );             // add to DOM
        
        window.addEventListener( 'resize', onWindowResize, false );   // window resize event runs onWindowResize() function
        
        stats = new Stats();                      // initialize stats.js performance monitor
        stats.showPanel( 0 );                     // select starting info panel (0: fps, 1: ms, 2: mb, 3+: custom)
        document.body.appendChild( stats.dom );   // add to DOM

        const geometry = new THREE.BoxGeometry( 1, 1, 1 );                      // create a box with dimensions x,y,z at center of scene (default location)
        const texture = new THREE.TextureLoader().load( 'image-400x300.jpg' );  // load custom image file
        texture.minFilter = THREE.NearestFilter;                                // crisper image quality like original image, less blur, more readable
        texture.magFilter = THREE.LinearFilter;                                 // default; weighted average of mipmaps
        const material = new THREE.MeshLambertMaterial( { map: texture } );     // use custom texture with Lambert
        cube = new THREE.Mesh( geometry, material );                            // combine geometry and material to create a mesh object for use in the scene
        scene.add( cube );                                                      // added to center of scene by default
      
        camera.position.set( 0, 0, 6 );   // move the camera back to view cube (x,y,z)

        controls.update();    //controls.update() must be called after any manual changes to the camera's transform
        
        // Grids

        const size = 12;                                                // size of the grids
        const divisions = 10;                                           // number of divisions in the grids
        
        const gridBack = new THREE.GridHelper( size, divisions );     // create a plane grid using GridHelper
        gridBack.position.set(0,0,-(size / 2));                       // centerpoint(x,y,z); at half grid size for a square
        gridBack.rotation.x = Math.PI/2;                              // set grid rotation; rotate 180
        scene.add( gridBack );                                        // add to scene
        
        const gridFront = new THREE.GridHelper( size, divisions );     
        gridFront.position.set(0,0,(size / 2));                            
        gridFront.rotation.x = Math.PI/2;                            
        scene.add( gridFront );

        const gridTop = new THREE.GridHelper( size, divisions );     
        gridTop.position.set(0,(size / 2),0);                                                     
        scene.add( gridTop );
        
        const gridBottom = new THREE.GridHelper( size, divisions );     
        gridBottom.position.set(0,-(size / 2),0);                                                     
        scene.add( gridBottom );
        
        const gridLeft = new THREE.GridHelper( size, divisions );     
        gridLeft.position.set(-(size / 2),0,0);
        gridLeft.rotation.z = Math.PI/2;
        scene.add( gridLeft );
        
        const gridRight = new THREE.GridHelper( size, divisions );     
        gridRight.position.set((size / 2),0,0);
        gridRight.rotation.z = Math.PI/2;
        scene.add( gridRight );

        // Lighting
        
        // add soft lighting to entire scene, no light source
        const light = new THREE.AmbientLight( 0x4d4d4d );    // lightness value of 0.30
        scene.add( light );
        
        // (colored) directional light at (0-1) intensity
        const directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );    // (white, 100%)
        directionalLight.position.set(0,1,0);    // change light source position property (xyz clip coord)
        scene.add( directionalLight );
      }
      
      
      
      // Responsive
      
      // update renderer on window resize event
      function onWindowResize() {                                     // event listener located in init() function
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
        
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

      
      
      // Animation
      
      // animate the scene
			function animate() {
        requestAnimationFrame( animate );      // request a new frame at default 60fps
        
        render();                              // call the render function to draw the scene
        
        stats.update();                        // update stats.js fps monitor
			}
      
      
      
      // Draw
      
      // draw/render this every frame
      function render() {
				cube.rotation.x += 0.01;            // rotate and concat this amount each frame
				cube.rotation.y += 0.01;
        
        renderer.render(scene, camera);     // render the scene and camera
      }

		</script>
	</body>
</html>